<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Guida dettagliata ad ASP.NET MVC 5 (Italiano)</title>
  <style>
    body { font-family: Inter, Arial, Helvetica, sans-serif; max-width:1200px; margin:2rem auto; padding:0 1rem; color:#222; line-height:1.6; }
    header h1 { margin:0 0 .2rem 0; font-size:1.9rem; }
    nav { margin:1rem 0; }
    nav a { margin-right:1rem; color:#0b66c3; text-decoration:none; }
    section { margin:1.5rem 0; padding:1rem; border:1px solid #e8e8e8; border-radius:6px; background:#fff; }
    pre { background:#1e1e1e; color:#dcdcdc; padding:1rem; overflow:auto; border-radius:4px; }
    code { font-family: Consolas, "Courier New", monospace; }
    h2,h3 { margin-top:0; }
    ul { margin:0.5rem 0 0.5rem 1.2rem; }
    .note { background:#fffbe6; border-left:4px solid #ffd24d; padding:.6rem; border-radius:4px; display:block; margin:0.8rem 0; }
    footer { font-size:.9rem; color:#666; margin-top:2rem; }
    .small { font-size:.95rem; color:#444; }
    table { border-collapse: collapse; }
    table td, table th { border: 1px solid #ddd; padding: 6px 8px; }
  </style>
</head>
<body>
  <header>
    <h1>Guida MOLTO dettagliata ad ASP.NET MVC 5</h1>
    <p class="small">Questa guida copre: setup progetto, struttura, routing, controller, action results, Razor views, model binding, validazione, Entity Framework 6 (Code First), dependency injection (Autofac), OWIN/Identity, security (CSRF, XSS), caching, performance, testing, logging, deployment su IIS e best practice. Livello: da principiante avanzato fino a concetti da produzione.</p>
  </header>

  <nav>
    <a href="#intro">Introduzione</a>
    <a href="#setup">Setup progetto</a>
    <a href="#structure">Struttura progetto</a>
    <a href="#routing">Routing & Attribute Routing</a>
    <a href="#controllers">Controller e Action</a>
    <a href="#views">Razor Views</a>
    <a href="#models">Models & ViewModel</a>
    <a href="#model-binding">Model binding & Validation</a>
    <a href="#ef6">Entity Framework 6 (Code First)</a>
    <a href="#di">Dependency Injection (Autofac)</a>
    <a href="#owin-identity">OWIN & ASP.NET Identity</a>
    <a href="#security">Sicurezza</a>
    <a href="#caching-performance">Caching & Performance</a>
    <a href="#logging-testing">Logging & Testing</a>
    <a href="#error-handling">Error handling & Global Filters</a>
    <a href="#deployment">Deployment su IIS</a>
    <a href="#best-practices">Best practice</a>
    <a href="#cheatsheet">Cheatsheet comandi</a>
  </nav>

  <section id="intro">
    <h2>Introduzione</h2>
    <p>ASP.NET MVC 5 è il framework Microsoft per applicazioni web server-rendered che usa il pattern Model-View-Controller. È maturo, testabile e si integra con OWIN, Identity e librerie server-side (EF6, Autofac ecc.). Questa guida assume Visual Studio (2015/2017/2019/2022) e .NET Framework 4.8.</p>
  </section>

  <section id="setup">
    <h2>Setup progetto</h2>
    <h3>Creare progetto in Visual Studio</h3>
    <ol>
      <li>File → New → Project → ASP.NET Web Application (.NET Framework)</li>
      <li>Seleziona "MVC" nello starter template. Questo include bootstrap, jQuery, AccountController template con Identity e cartelle tipiche.</li>
      <li>Scegli .NET Framework 4.6/4.7/4.8 (compatibilità con MVC5).</li>
    </ol>

    <h3>Pacchetti NuGet utili</h3>
    <pre><code class="language-bash">Install-Package EntityFramework
Install-Package Microsoft.AspNet.Identity.EntityFramework
Install-Package Microsoft.Owin.Host.SystemWeb
Install-Package Autofac
Install-Package Autofac.Mvc5
Install-Package Newtonsoft.Json
Install-Package Serilog
Install-Package Serilog.Sinks.File
Install-Package Moq
Install-Package NUnit</code></pre>

    <p class="note">Usa Package Manager Console o NuGet UI. Tieni presenti bindingRedirect in Web.config se necessario.</p>
  </section>

  <section id="structure">
    <h2>Struttura tipica di un progetto MVC 5</h2>
    <ul>
      <li>Controllers/ — controller MVC</li>
      <li>Models/ — classi di dominio e viewmodel</li>
      <li>Views/ — cartelle per controller + Shared (layout, _ViewStart, _ViewImports non in MVC5)</li>
      <li>Scripts/ e Content/ — JS, CSS, immagini</li>
      <li>App_Start/ — RouteConfig, FilterConfig, BundleConfig, IdentityConfig</li>
      <li>Global.asax — Application_Start</li>
      <li>Startup.cs — OWIN startup (se presente)</li>
      <li>Web.config — configurazioni runtime, connectionStrings, customErrors</li>
    </ul>
  </section>

  <section id="routing">
    <h2>Routing & Attribute Routing</h2>
    <h3>RouteConfig (convenzionale)</h3>
    <pre><code class="language-csharp">// App_Start/RouteConfig.cs
public class RouteConfig
{
    public static void RegisterRoutes(RouteCollection routes)
    {
        routes.IgnoreRoute("{resource}.axd/{*pathInfo}");
        routes.MapRoute(
            name: "Default",
            url: "{controller}/{action}/{id}",
            defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
        );
    }
}</code></pre>

    <h3>Attribute Routing</h3>
    <p>Più leggibile per API o per controller con percorsi specifici. Abilitalo in Global.asax o WebApiConfig:</p>
    <pre><code class="language-csharp">// Global.asax.cs -> Application_Start
RouteTable.Routes.MapMvcAttributeRoutes();</code></pre>
    <pre><code class="language-csharp">// Controller
[RoutePrefix("products")]
public class ProductsController : Controller
{
    [Route("")] // /products
    public ActionResult Index() { ... }

    [Route("{id:int}")] // /products/5
    public ActionResult Details(int id) { ... }
}</code></pre>

    <p class="note">L'attribute routing dà controllo granulare, ma tieni coerenza con routing convenzionale se entrambi sono usati.</p>
  </section>

  <section id="controllers">
    <h2>Controller e Action</h2>
    <h3>Controller base</h3>
    <pre><code class="language-csharp">public class ProductController : Controller
{
    // Sincrona
    public ActionResult Index()
    {
        var items = _service.GetAll();
        return View(items);
    }

    // Asincrona con EF
    public async Task&lt;ActionResult&gt; Details(int id)
    {
        var item = await _db.Products.FindAsync(id);
        if (item == null) return HttpNotFound();
        return View(item);
    }

    [HttpPost]
    [ValidateAntiForgeryToken]
    public ActionResult Create(ProductViewModel vm)
    {
        if (!ModelState.IsValid) return View(vm);
        _service.Create(vm);
        return RedirectToAction("Index");
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing) _db.Dispose();
        base.Dispose(disposing);
    }
}</code></pre>

    <h3>Action Results</h3>
    <ul>
      <li>View() — renderizza view Razor</li>
      <li>RedirectToAction(...) — redirect interno</li>
      <li>Json(...) — ritorna JSON (usa JsonRequestBehavior.AllowGet con GET)</li>
      <li>HttpNotFound(), new HttpStatusCodeResult(403), HttpStatusCodeResult</li>
      <li>File(...) — restituisci file</li>
    </ul>

    <h3>Best practice per controller</h3>
    <ul>
      <li>Logica business nel service layer, non direttamente nel controller.</li>
      <li>Usa viewmodel strettamente legati alla view.</li>
      <li>Preferisci azioni asincrone se fai I/O-bound.</li>
      <li>Sostituisci magic strings con nameof(controller/action) in RedirectToAction quando possibile.</li>
    </ul>
  </section>

  <section id="views">
    <h2>Razor Views</h2>
    <h3>_ViewStart.cshtml e _Layout.cshtml</h3>
    <pre><code class="language-razor">@{
    Layout = "~/Views/Shared/_Layout.cshtml";
}</code></pre>
    <p>Il layout contiene <code>&lt;head&gt;</code>, riferimenti a bundle, e una section per script in fondo.</p>

    <h3>Esempio View</h3>
    <pre><code class="language-razor">@model IEnumerable&lt;MyApp.ViewModels.ProductViewModel&gt;

@{
    ViewBag.Title = "Prodotti";
}

&lt;h2&gt;Prodotti&lt;/h2&gt;
&lt;table class="table"&gt;
    &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Id&lt;/th&gt;&lt;th&gt;Nome&lt;/th&gt;&lt;th&gt;Prezzo&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
    &lt;tbody&gt;
    @foreach(var p in Model) {
        &lt;tr&gt;
            &lt;td&gt;@p.Id&lt;/td&gt;
            &lt;td&gt;@Html.Encode(p.Name)&lt;/td&gt;
            &lt;td&gt;@String.Format("{0:C}", p.Price)&lt;/td&gt;
        &lt;/tr&gt;
    }
    &lt;/tbody&gt;
&lt;/table&gt;</code></pre>

    <h3>HTML Helpers e TagHelpers?</h3>
    <p>MVC5 usa HTML Helpers: Html.TextBoxFor, Html.LabelFor, Html.Partial. TagHelpers sono introdotti in ASP.NET Core, non in MVC5.</p>

    <h3>Partial Views e Editor/Display Templates</h3>
    <p>Usa partial view per riutilizzo (Html.Partial, Html.RenderPartial) e EditorTemplates/DisplayTemplates per rendering coerente di tipi e modelli.</p>
  </section>

  <section id="models">
    <h2>Models & ViewModel</h2>
    <p>Separare model di dominio da viewmodel è fondamentale per sicurezza e mantenibilità.</p>

    <h3>Esempio Model e ViewModel</h3>
    <pre><code class="language-csharp">public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}

public class ProductViewModel
{
    public int Id { get; set; }

    [Required]
    [StringLength(100)]
    public string Name { get; set; }

    [Range(0.01, double.MaxValue)]
    public decimal Price { get; set; }
}</code></pre>

    <p class="note">Mapping tra domain model e viewmodel: AutoMapper è molto usato per evitare codice boilerplate.</p>
  </section>

  <section id="model-binding">
    <h2>Model binding e validazione</h2>
    <h3>Model binding</h3>
    <p>Mvc binder mappa form fields, route values, query string in oggetti C# automaticamente. Per comportamenti custom crea un IModelBinder personalizzato.</p>

    <h3>Esempio Custom Model Binder</h3>
    <pre><code class="language-csharp">public class CommaSeparatedIntArrayBinder : IModelBinder
{
    public object BindModel(ControllerContext controllerContext, ModelBindingContext bindingContext)
    {
        var key = bindingContext.ModelName;
        var value = controllerContext.HttpContext.Request.Form[key];
        if (String.IsNullOrEmpty(value)) return new int[0];
        return value.Split(',').Select(s =&gt; int.Parse(s)).ToArray();
    }
}
// Registrazione in Global.asax
ModelBinders.Binders.Add(typeof(int[]), new CommaSeparatedIntArrayBinder());</code></pre>

    <h3>Validazione</h3>
    <ul>
      <li>DataAnnotations: [Required], [StringLength], [Range], [RegularExpression]</li>
      <li>Server-side: ModelState.IsValid</li>
      <li>Client-side: jQuery Validate + Unobtrusive validation (inclusi nei template MVC)</li>
      <li>Validazione custom: IValidatableObject o Custom ValidationAttribute</li>
    </ul>

    <h3>Esempio Custom ValidationAttribute</h3>
    <pre><code class="language-csharp">public class EvenNumberAttribute : ValidationAttribute
{
    public override bool IsValid(object value)
    {
        if (value == null) return true;
        int i;
        if (int.TryParse(value.ToString(), out i))
        {
            return i % 2 == 0;
        }
        return false;
    }
}</code></pre>

    <p class="note">Non fidarti del client-side: valida sempre sul server.</p>
  </section>

  <section id="ef6">
    <h2>Entity Framework 6 (Code First) — uso pratico</h2>
    <h3>Definizione DbContext & DbSet</h3>
    <pre><code class="language-csharp">public class AppDbContext : DbContext
{
    public AppDbContext() : base("DefaultConnection") { }

    public DbSet&lt;Product&gt; Products { get; set; }

    protected override void OnModelCreating(DbModelBuilder modelBuilder)
    {
        // configurazioni fluent API se necessarie
        base.OnModelCreating(modelBuilder);
    }
}</code></pre>

    <h3>Migrations</h3>
    <pre><code class="language-bash">Enable-Migrations
Add-Migration InitialCreate
Update-Database</code></pre>

    <h3>Esempio repository minimale</h3>
    <pre><code class="language-csharp">public interface IProductRepository
{
    Task&lt;Product&gt; GetByIdAsync(int id);
    IQueryable&lt;Product&gt; Query();
    void Add(Product p);
    Task SaveChangesAsync();
}

public class ProductRepository : IProductRepository
{
    private readonly AppDbContext _db;
    public ProductRepository(AppDbContext db) { _db = db; }
    public Task&lt;Product&gt; GetByIdAsync(int id) => _db.Products.FindAsync(id);
    public IQueryable&lt;Product&gt; Query() => _db.Products;
    public void Add(Product p) => _db.Products.Add(p);
    public Task SaveChangesAsync() => _db.SaveChangesAsync();
}</code></pre>

    <p class="note">Per unit testing, astrai il context con repository/UnitOfWork oppure usa DbContextFactory con InMemory DB o Effort (tool di terze parti).</p>
  </section>

  <section id="di">
    <h2>Dependency Injection (Autofac) — integrazione MVC5</h2>
    <pre><code class="language-csharp">// App_Start/AutofacConfig.cs
using Autofac;
using Autofac.Integration.Mvc;
public static class AutofacConfig
{
    public static void RegisterDependencies()
    {
        var builder = new ContainerBuilder();
        builder.RegisterControllers(Assembly.GetExecutingAssembly());

        // Registrazioni
        builder.RegisterType&lt;AppDbContext&gt;().InstancePerRequest();
        builder.RegisterType&lt;ProductRepository&gt;().As&lt;IProductRepository&gt;().InstancePerRequest();
        builder.RegisterType&lt;ProductService&gt;().As&lt;IProductService&gt;().InstancePerRequest();

        var container = builder.Build();
        DependencyResolver.SetResolver(new AutofacDependencyResolver(container));
    }
}
// Chiamare AutofacConfig.RegisterDependencies() in Application_Start()
</code></pre>

    <p class="note">InstancePerRequest è importante per oggetti con ciclo vita legato alla request (DbContext).</p>
  </section>

  <section id="owin-identity">
    <h2>OWIN & ASP.NET Identity (login, cookie, external providers)</h2>
    <h3>Startup OWIN</h3>
    <pre><code class="language-csharp">using Microsoft.Owin;
using Owin;
using Microsoft.Owin.Security.Cookies;
[assembly: OwinStartup(typeof(MyApp.Startup))]
namespace MyApp
{
    public class Startup
    {
        public void Configuration(IAppBuilder app)
        {
            app.UseCookieAuthentication(new CookieAuthenticationOptions
            {
                AuthenticationType = DefaultAuthenticationTypes.ApplicationCookie,
                LoginPath = new PathString("/Account/Login"),
                ExpireTimeSpan = TimeSpan.FromDays(14),
                SlidingExpiration = true
            });

            // External providers (esempio Google)
            // app.UseGoogleAuthentication(clientId: "...", clientSecret: "...");
        }
    }
}</code></pre>

    <h3>ASP.NET Identity: esempio UserManager e AccountController</h3>
    <p>I template MVC includono Identity con ApplicationUser, ApplicationDbContext e AccountController già pronti. Un esempio minimo di login:</p>
    <pre><code class="language-csharp">[HttpPost]
[AllowAnonymous]
[ValidateAntiForgeryToken]
public async Task&lt;ActionResult&gt; Login(LoginViewModel model, string returnUrl)
{
    if (!ModelState.IsValid) return View(model);

    var user = await UserManager.FindAsync(model.Email, model.Password);
    if (user != null)
    {
        await SignInManager.SignInAsync(user, isPersistent: model.RememberMe, rememberBrowser: false);
        return RedirectToLocal(returnUrl);
    }
    ModelState.AddModelError("", "Invalid login attempt.");
    return View(model);
}</code></pre>

    <p class="note">Gestire lockout, email confirmation, 2FA per produzione.</p>
  </section>

  <section id="security">
    <h2>Sicurezza in MVC5</h2>

    <h3>Protezione CSRF</h3>
    <p>Usa @Html.AntiForgeryToken() nelle form e [ValidateAntiForgeryToken] sulle action POST.</p>
    <pre><code class="language-razor">&lt;form method="post"&gt;
    @Html.AntiForgeryToken()
    &lt;input type="text" name="Name" /&gt;
&lt;/form&gt;</code></pre>

    <h3>XSS</h3>
    <ul>
      <li>Output encode: Razor encode in automatico con @variabile; usa Html.Raw solo quando sei sicuro.</li>
      <li>Sanitizza input HTML con librerie come HtmlSanitizer se accetti rich HTML.</li>
    </ul>

    <h3>SQL Injection</h3>
    <p>Usa EF/parametrized queries, non concatenare stringhe per SQL.</p>

    <h3>Header di sicurezza</h3>
    <pre><code class="language-xml">&lt;system.webServer&gt;
  &lt;httpProtocol&gt;
    &lt;customHeaders&gt;
      &lt;add name="X-Frame-Options" value="DENY" /&gt;
      &lt;add name="X-Content-Type-Options" value="nosniff" /&gt;
      &lt;add name="X-XSS-Protection" value="1; mode=block" /&gt;
    &lt;/customHeaders&gt;
  &lt;/httpProtocol&gt;
&lt;/system.webServer&gt;</code></pre>

    <h3>Autorizzazione</h3>
    <pre><code class="language-csharp">[Authorize] // su controller o azione
[Authorize(Roles = "Admin")] // restrizione per ruolo
[AllowAnonymous] // override per azioni pubbliche</code></pre>

    <p class="note">Usa HTTPS sempre in produzione e forza redirect a HTTPS (rewrite rule o middleware).</p>
  </section>

  <section id="caching-performance">
    <h2>Caching & Performance</h2>

    <h3>Bundling e Minification</h3>
    <pre><code class="language-csharp">// App_Start/BundleConfig.cs
bundles.Add(new ScriptBundle("~/bundles/jquery").Include(
            "~/Scripts/jquery-{version}.js"));
bundles.Add(new StyleBundle("~/Content/css").Include(
            "~/Content/bootstrap.css", "~/Content/site.css"));</code></pre>

    <h3>Output Caching</h3>
    <pre><code class="language-csharp">[OutputCache(Duration = 60, VaryByParam = "none")]
public ActionResult Index() { ... }</code></pre>

    <h3>Cache profili in Web.config</h3>
    <pre><code class="language-xml">&lt;system.web&gt;
  &lt;caching&gt;
    &lt;outputCacheSettings&gt;
      &lt;outputCacheProfiles&gt;
        &lt;add name="Cache1Min" duration="60" varyByParam="none" /&gt;
      &lt;/outputCacheProfiles&gt;
    &lt;/outputCacheSettings&gt;
  &lt;/caching&gt;
&lt;/system.web&gt;</code></pre>

    <h3>In-memory cache e distributed cache</h3>
    <p>System.Runtime.Caching.MemoryCache per cache locale; per scale-out usare Redis o SQL Server cache.</p>

    <h3>Asincronia e scalabilità</h3>
    <p>Azione async libera il thread worker durante I/O (DB/HTTP). EF6 supporta metodi async come ToListAsync, FindAsync.</p>

    <h3>Pooling connessioni e using</h3>
    <p>Aprite e chiudete connessioni DB spesso (using) per sfruttare pool di connessioni.</p>
  </section>

  <section id="logging-testing">
    <h2>Logging & Testing</h2>

    <h3>Logging (Serilog esempio)</h3>
    <pre><code class="language-csharp">// Global.asax.cs
Log.Logger = new LoggerConfiguration()
    .WriteTo.File("logs\\log-.txt", rollingInterval: RollingInterval.Day)
    .CreateLogger();

Log.Information("Application starting");</code></pre>

    <h3>Unit Testing Controller (Moq + NUnit esempio)</h3>
    <pre><code class="language-csharp">[Test]
public async Task Details_ReturnsViewWithProduct()
{
    var mockRepo = new Mock&lt;IProductRepository&gt;();
    mockRepo.Setup(r =&gt; r.GetByIdAsync(1)).ReturnsAsync(new Product { Id = 1, Name = "X" });
    var controller = new ProductController(mockRepo.Object);

    var result = await controller.Details(1) as ViewResult;
    Assert.IsNotNull(result);
    var model = result.Model as Product;
    Assert.AreEqual(1, model.Id);
}</code></pre>

    <p class="note">Separare logica in services facilita i test. Per testare DbContext puoi usare database in-memory o test doubles.</p>
  </section>

  <section id="error-handling">
    <h2>Error handling & Global Filters</h2>

    <h3>HandleErrorAttribute</h3>
    <pre><code class="language-csharp">// FilterConfig.cs
public class FilterConfig
{
    public static void RegisterGlobalFilters(GlobalFilterCollection filters)
    {
        filters.Add(new HandleErrorAttribute { View = "Error" });
    }
}</code></pre>

    <p>In Web.config abilita customErrors e definisci view per gli errori:</p>
    <pre><code class="language-xml">&lt;system.web&gt;
  &lt;customErrors mode="On" defaultRedirect="~/Error"&gt;
    &lt;error statusCode="404" redirect="~/Error/NotFound" /&gt;
  &lt;/customErrors&gt;
&lt;/system.web&gt;</code></pre>

    <h3>Logging eccezioni globali</h3>
    <pre><code class="language-csharp">protected void Application_Error()
{
    var ex = Server.GetLastError();
    // loggare ex con Serilog/NLog
    Response.Clear();
    Server.ClearError();
    Response.Redirect("~/Error"); // o restituisce stato JSON se richiesta AJAX
}</code></pre>

    <p class="note">Gestire errori per richieste AJAX separatamente (controlla header X-Requested-With).</p>
  </section>

  <section id="deployment">
    <h2>Deployment su IIS (sintesi)</h2>
    <h3>Prerequisiti</h3>
    <ul>
      <li>IIS con .NET Extensibility e ASP.NET 4.8 abilitati</li>
      <li>Application Pool con .NET CLR v4.0.x e Managed Pipeline = Integrated</li>
    </ul>

    <h3>Passi principali</h3>
    <ol>
      <li>Build in Release</li>
      <li>Publish &gt; Folder o Web Deploy</li>
      <li>Copiati i file nella cartella del sito su server</li>
      <li>Imposta App Pool identity e concedi permessi NTFS (IIS_IUSRS o account custom)</li>
      <li>Configura binding SSL e hostname</li>
      <li>Abilita logging, monitoring e health checks</li>
    </ol>

    <h3>Zero-downtime</h3>
    <ul>
      <li>Usa app_offline.htm se si accettano downtime brevi</li>
      <li>Per zero-downtime: deploy su cartelle separate e swap di virtual directories, o usare load balancer e rolling update</li>
    </ul>

    <p class="note">Controlla file locks: alcune librerie bloccano file finché process non è riavviato; fare app pool recycle quando necessario.</p>
  </section>

  <section id="best-practices">
    <h2>Best practice e checklist</h2>
    <ul>
      <li>Separare responsabilità: Controller thin, Service layer, Repository per dati.</li>
      <li>Usare viewmodels per evitare over-posting (model binding su proprietà sensibili).</li>
      <li>Validare sempre sul server; sanificare output.</li>
      <li>Automatizzare build & deploy (CI/CD).</li>
      <li>Monitorare in produzione (logs, perf counters, APM).</li>
      <li>Gestire session state per scalabilità (evitare in-proc se si scala su più server).</li>
      <li>Controllare versioni di librerie NuGet e aggiornare bindingRedirect.</li>
      <li>Scrivere test automatici (unit & integration) per logica critica e API.</li>
      <li>Limitare dimensione delle response e abilitare compressione GZIP/Deflate in IIS.</li>
    </ul>
  </section>

  <section id="cheatsheet">
    <h2>Cheatsheet comandi & riferimenti rapidi</h2>
    <table>
      <tr><th>Scopo</th><th>Comando / Codice</th></tr>
      <tr><td>Enable Migrations EF</td><td><code>Enable-Migrations</code></td></tr>
      <tr><td>Aggiungi migration</td><td><code>Add-Migration Nome</code></td></tr>
      <tr><td>Update DB</td><td><code>Update-Database</code></td></tr>
      <tr><td>Install Pacchetto</td><td><code>Install-Package NomePacchetto</code></td></tr>
      <tr><td>Creare bundle</td><td>BundleConfig + BundleTable.EnableOptimizations = true</td></tr>
      <tr><td>Abilitare attribute routing</td><td><code>RouteTable.Routes.MapMvcAttributeRoutes();</code></td></tr>
      <tr><td>Abilitare Autofac</td><td>AutofacConfig.RegisterDependencies() in Application_Start()</td></tr>
      <tr><td>OWIN Startup</td><td>Classe Startup con [assembly: OwinStartup]</td></tr>
    </table>
  </section>

  <footer>
    <p>Guida generata il 2025-12-26. Posso esportare questo contenuto come progetto template: generare file .csproj, controllers, views, Web.config, Startup.cs e script di deployment (Web Deploy) pronti da importare in Visual Studio. Dimmi se vuoi il progetto completo (seed di esempio: Product CRUD + EF6 + Autofac + Identity) e lo preparo con tutti i file singoli.</p>
  </footer>
</body>
</html>